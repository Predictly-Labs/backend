// This is your Prisma schema file,
// learn more at: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ══════════════════════════════════════════════════════════════
// USER & AUTH
// ══════════════════════════════════════════════════════════════

model User {
  id              String   @id @default(uuid())
  privyId         String   @unique
  walletAddress   String?  @unique
  displayName     String?
  avatarUrl       String?
  
  // Stats (cached for leaderboard)
  totalPredictions   Int   @default(0)
  correctPredictions Int   @default(0)
  totalEarnings      Float @default(0)
  currentStreak      Int   @default(0)
  
  // Subscription
  isPro           Boolean   @default(false)
  proExpiresAt    DateTime?
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // Relations
  memberships     GroupMember[]
  votes           Vote[]
  createdMarkets  PredictionMarket[] @relation("MarketCreator")
  resolvedMarkets PredictionMarket[] @relation("MarketResolver")
  createdGroups   Group[]            @relation("GroupCreator")
}

// ══════════════════════════════════════════════════════════════
// GROUP & MEMBERSHIP
// ══════════════════════════════════════════════════════════════

model Group {
  id              String   @id @default(uuid())
  name            String
  description     String?
  iconUrl         String?
  inviteCode      String   @unique
  isPublic        Boolean  @default(true)
  
  createdById     String
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // Relations
  createdBy       User          @relation("GroupCreator", fields: [createdById], references: [id])
  members         GroupMember[]
  markets         PredictionMarket[]
}

model GroupMember {
  id              String    @id @default(uuid())
  groupId         String
  userId          String
  role            GroupRole @default(MEMBER)
  
  joinedAt        DateTime  @default(now())
  
  // Relations
  group           Group     @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([groupId, userId])
  @@index([groupId])
  @@index([userId])
}

enum GroupRole {
  ADMIN
  JUDGE
  MODERATOR
  MEMBER
}

// ══════════════════════════════════════════════════════════════
// PREDICTION MARKET
// ══════════════════════════════════════════════════════════════

model PredictionMarket {
  id              String        @id @default(uuid())
  onChainId       String?       @unique
  
  groupId         String
  title           String
  description     String?
  imageUrl        String?
  
  // Market config
  marketType      MarketType    @default(STANDARD)
  endDate         DateTime
  minStake        Float         @default(0.1)
  maxStake        Float?
  
  // Cached stats (synced from on-chain)
  status          MarketStatus  @default(ACTIVE)
  outcome         MarketOutcome?
  totalVolume     Float         @default(0)
  yesPool         Float         @default(0)
  noPool          Float         @default(0)
  yesPercentage   Float         @default(50)
  noPercentage    Float         @default(50)
  participantCount Int          @default(0)
  
  // Resolution
  resolvedById    String?
  resolvedAt      DateTime?
  resolutionNote  String?
  
  createdById     String
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  
  // Relations
  group           Group         @relation(fields: [groupId], references: [id], onDelete: Cascade)
  creator         User          @relation("MarketCreator", fields: [createdById], references: [id])
  resolver        User?         @relation("MarketResolver", fields: [resolvedById], references: [id])
  votes           Vote[]
  
  @@index([groupId])
  @@index([status])
  @@index([createdById])
}

enum MarketType {
  STANDARD
  NO_LOSS
  WITH_YIELD
}

enum MarketStatus {
  ACTIVE
  PENDING
  RESOLVED
  DISPUTED
  CANCELLED
}

enum MarketOutcome {
  YES
  NO
  INVALID
}

// ══════════════════════════════════════════════════════════════
// VOTES & BETS
// ══════════════════════════════════════════════════════════════

model Vote {
  id              String         @id @default(uuid())
  onChainTxHash   String?        @unique
  
  marketId        String
  userId          String
  prediction      VotePrediction
  amount          Float
  
  // Reward tracking
  hasClaimedReward Boolean @default(false)
  rewardAmount    Float?
  
  createdAt       DateTime @default(now())
  
  // Relations
  market          PredictionMarket @relation(fields: [marketId], references: [id], onDelete: Cascade)
  user            User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([marketId, userId])
  @@index([marketId])
  @@index([userId])
}

enum VotePrediction {
  YES
  NO
}

// ══════════════════════════════════════════════════════════════
// GAMIFICATION
// ══════════════════════════════════════════════════════════════

model Badge {
  id              String   @id @default(uuid())
  name            String   @unique
  description     String
  iconUrl         String
  requirement     String
  
  userBadges      UserBadge[]
}

model UserBadge {
  id              String   @id @default(uuid())
  userId          String
  badgeId         String
  earnedAt        DateTime @default(now())
  
  // Relations
  badge           Badge    @relation(fields: [badgeId], references: [id], onDelete: Cascade)
  
  @@unique([userId, badgeId])
  @@index([userId])
  @@index([badgeId])
}
